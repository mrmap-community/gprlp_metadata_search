# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoportalRlpMetadataSearch
                                 A QGIS plugin
 GeoPortal.rlp metadata search module
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-02-09
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Armin Retterath
        email                : armin.retterath@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import Qt, QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QPixmap
#from qgis.PyQt.QtWidgets import QAction, QMessageBox
from qgis.PyQt.QtWidgets import *
# some things for doing http requests
from qgis.PyQt.QtCore import QUrl, QEventLoop, QUrlQuery
from qgis.PyQt.QtNetwork import QNetworkRequest
from qgis.core import Qgis, QgsNetworkAccessManager, QgsMessageLog, QgsSettings, QgsProviderRegistry, QgsBrowserModel, QgsProject, QgsRasterLayer
from qgis.gui import QgsMessageBar, QgsGui
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .gprlp_metadata_search_dialog import GeoportalRlpMetadataSearchDialog
import os.path
import urllib
import requests
# some libs for json parsing under python3
import json
import re
import math
from types import SimpleNamespace


class GeoportalRlpMetadataSearch:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GeoportalRlpMetadataSearch_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GeoPortal.rlp Metadata Search')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # read all settings from qgis settings
        self.settings = QgsSettings()

        # read actual browser model
        self.browser_model = QgsBrowserModel()

        # definition of searchResources
        self.search_resources = [
            "wmc",
            "wms"
        ]

        # definition of searchResources new
        self.search_resources_list = [
            {
                "title": "OWS Context",
                "value": "wmc",
                },
            {
                "title": "Map Layer",
                "value": "wms",
                },
        ]

        # definition of catalogue uri
        self.search_catalogues = [
            {
                "title": "Rhineland-Palatinate",
                "value": "https://www.geoportal.rlp.de",
                },
            {
                "title": "Hesse",
                "value": "https://www.geoportal.hessen.de",
                },
            {
                "title": "Saarland",
                "value": "https://geoportal.saarland.de",
                },
        ]


        #network access
        self.na_manager = QgsNetworkAccessManager.instance()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GeoportalRlpMetadataSearch', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToWebMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gprlp_metadata_search/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'GeoPortal.rlp metadata search'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginWebMenu(
                self.tr(u'&GeoPortal.rlp Metadata Search'),
                action)
            self.iface.removeToolBarIcon(action)


    def clean_ows_url(self, url):
        """clean an OWS URL of added basic service parameters"""
        url = QUrl(url)
        query_string = url.query()
        if query_string:
            query_string = QUrlQuery(query_string)
            query_string.removeQueryItem('service')
            query_string.removeQueryItem('SERVICE')
            query_string.removeQueryItem('request')
            query_string.removeQueryItem('REQUEST')
            url.setQuery(query_string)
        return url.toString()


    def add_ows(self, data_url):

        # from MetaSearch Plugin - thx to tom
        # https://github.com/qgis/QGIS/blob/master/python/plugins/MetaSearch/dialogs/maindialog.py#L708
        #
        # from https://github.com/qgis/QGIS/blob/4ff41e71ad7a397ca05af4186ea0339af81752cc/python/plugins/MetaSearch/util.py

        # QgsMessageLog.logMessage("Url to clean: " + data_url, 'GeoPortal.rlp search', level=Qgis.Info)

        QgsMessageLog.logMessage("Load WMS cleaned url: " + self.clean_ows_url(data_url), 'GeoPortal.rlp search', level=Qgis.Info)

        service_type = ['OGC:WMS/OGC:WMTS', 'wms', 'wms']
        service_name = '%s from GeoPortal.rlp context search' % service_type[1]
        conn_name_matches = []



        # store connection in browser
        # check if there is a connection with same name

        self.settings.beginGroup('/qgis/connections-%s' % service_type[1])
        keys = self.settings.childGroups()
        self.settings.endGroup()

        for key in keys:
            if key.startswith(service_name):
                conn_name_matches.append(key)
        if conn_name_matches:
            service_name = conn_name_matches[-1]

        # check for duplicates
        """
        if service_name in keys:  # duplicate found
            msg = self.tr('Connection {0} exists. Overwrite?').format(service_name)
            res = QMessageBox.warning(
                self, self.tr('Saving server'), msg,
                QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)
            if res == QMessageBox.No:  # assign new name with serial
                service_name = serialize_string(service_name)
            elif res == QMessageBox.Cancel:
                return
        """

        # no duplicates detected or overwrite is allowed
        self.settings.beginGroup('/qgis/connections-%s' % service_type[1])
        self.settings.setValue('/%s/url' % service_name, self.clean_ows_url(data_url))
        self.settings.endGroup()
        #refresh browser content - but howto reload tree?
        # only refresh the view not the model!

        # self.browser_model.initialize()

        browser_model = self.iface.browserModel()
        browser_model.reload()

        browser_dock_widget = self.iface.mainWindow().findChildren(QWidget, 'Browser')[0]
        tree = browser_dock_widget.findChildren(QTreeView)
        tree_0 = tree[0]
        proxy = tree_0.model()
        # print(proxy.rowCount()) - 16
        # only for the first level - column = 0
        """
        for row in range(proxy.rowCount()):
            index = proxy.index(row, 0)
            tree_0.expand(index)
        """
        # simply add wms layer
        # rlayer = QgsRasterLayer(clean_ows_url(data_url), 'test', 'wms')
        # QgsProject.instance().addMapLayer(rlayer)


        # tree_0.expand(10)

        #self.iface.mainWindow().findChildren(QWidget, 'Browser')[0].refresh()
        # browser_model = self.iface.browserModel()
        # browser_model.reload()
        # browser_widget = self.iface.mainWindow().findChildren(QWidget, 'Browser')[0]

        # get child with id of wms ... and setExpanded https://doc.qt.io/qt-5/qtreeview.html#setExpanded
        # QTreeView::setTreePosition(int index)
        # open wms part?
        #self.browser_model.initialize()
        # QgsGui.QgsBrowserDockWidget.initialize()
        # QgsGui.
        return


        #wms_dlg = QgsProviderRegistry.instance()
        #wms_dlg.show()
        #provider_list = QgsGui.providerGuiRegistry.providerList()
        #for provider in provider_list:
        #    QgsMessageLog.logMessage("Provider: " + provider, 'GeoPortal.rlp search', level=Qgis.Info)
        """
        ows_provider = QgsGui.sourceSelectProviderRegistry().\
            createSelectionWidget(
                service_type[2], self, Qt.Widget,
                QgsProviderRegistry.WidgetMode.Embedded)
        
        ows_provider.addRasterLayer.connect(self.iface.addRasterLayer)
        conn_cmb = ows_provider.findChild(QWidget, 'cmbConnections')
        connect = 'btnConnect_clicked'
        ows_provider.setModal(False)
        ows_provider.show()

        # open provider dialogue against added OWS
        index = conn_cmb.findText(service_name)
        if index > -1:
            conn_cmb.setCurrentIndex(index)
        getattr(ows_provider, connect)()
        """
        pass

    def on_clicked_context_layer(self, item):
        """
        /***************************************************************************
        function which will be invoked, if a layer of the context layertree is selected
        /***************************************************************************
        """
        self.reset_resource_view()
        selected_feature = item.data(1, 0)
        QgsMessageLog.logMessage("Title of clicked layer: " + selected_feature.properties.title, 'GeoPortal.rlp search', level=Qgis.Info)
        # add layer title to resource view
        #self.dlg.resource_title.setText(selected_feature.properties.title)
        self.dlg.labelResourceType.setText("Context layer")
        self.dlg.textBrowserResourceAbstract.append(selected_feature.properties.title)
        # get getmap uri from offering
        offerings = selected_feature.offerings
        # test = json.dumps(offerings)
        # QgsMessageLog.logMessage("Offerings: " + str(test), 'GeoPortal.rlp search', level=Qgis.Info)
        wms_capabilities = False
        for offering in offerings:
            if offering.code == "http://www.opengis.net/spec/owc-atom/1.0/req/wms":
                QgsMessageLog.logMessage("Offering with wms code found", 'GeoPortal.rlp search', level=Qgis.Info)
                for operation in offering.operations:
                    if operation.code == "GetCapabilities":
                        wms_capabilities = operation.href
                        try:
                            capabilities_url = str(operation.href)
                            self.dlg.labelAccessUrl.setText('<a href="' + capabilities_url + '">GetCapabilities</a>')
                            self.dlg.labelAccessUrl.setOpenExternalLinks(True)
                            # add function to load button
                            self.dlg.pushButtonLoad.setEnabled(True)
                            self.dlg.pushButtonLoad.disconnect()
                            self.dlg.pushButtonLoad.clicked.connect(lambda: self.add_ows(capabilities_url))
                        except:
                            QgsMessageLog.logMessage("No attribute getCapabilitiesUrl for this resource",
                                                     'GeoPortal.rlp search',
                                                     level=Qgis.Info)
                    if operation.code == "GetMap":
                        QgsMessageLog.logMessage("GetMap found", 'GeoPortal.rlp search', level=Qgis.Info)
                        if wms_capabilities:
                            self.dlg.pushButtonLoad.setEnabled(True)
                            self.dlg.pushButtonLoad.disconnect()
                            self.dlg.pushButtonLoad.clicked.connect(lambda: self.add_ows(wms_capabilities))
                        else:
                            self.dlg.pushButtonLoad.disconnect()
                            self.dlg.pushButtonLoad.clicked.connect(lambda: self.add_ows(operation.href))
                        return
                    else:
                        pass
                        #self.dlg.resource_uri.setText("No WMS URI found!")


    def on_clicked_resource(self, item, type):
        QgsMessageLog.logMessage("type found: " + type, 'GeoPortal.rlp search', level=Qgis.Info)
        return
        type = "wmc"
        # check for type


        if type == "wmc":
            pass
        if type == "layer":
            pass
        if type == "context":
            pass



        pass


    def on_clicked_wmc(self, item):
        """Show detailed information about wmc in other """
        #QgsMessageLog.logMessage("Type: " + type, 'GeoPortal.rlp search',
        #                                 level=Qgis.Info)

        self.reset_resource_view()
        try:
            resource_id = item.data(1, 0).id
        except:
            QgsMessageLog.logMessage("No attribute id for this resource - no detailed info available", 'GeoPortal.rlp search',
                                         level=Qgis.Info)
            resource_id = 0

        self.dlg.labelResourceId.setText(str(resource_id))
        self.dlg.labelResourceType.setText("OWS Context")
        self.dlg.pushButtonLoad.setEnabled(False)
        self.dlg.textBrowserResourceAbstract.clear()
        self.dlg.treeWidgetResourceDetail.clear()
        # load preview image
        try:
            preview_url = item.data(1, 0).previewURL
            result_content = self.open_remote(preview_url)
            if result_content:
                # build
                pixmap = QPixmap()
                pixmap.loadFromData(result_content)
                # draw preview
                self.dlg.labelPreview.setPixmap(pixmap)
            else:
                QgsMessageLog.logMessage("An error occured while try to open url: " + request_url, 'GeoPortal.rlp search',
                                         level=Qgis.Critical)
        except:
            self.dlg.labelPreview.setText("No preview")
        try:
            load_count = str(item.data(1, 0).loadCount)
            self.dlg.labelLoadCount.setText(load_count)
        except:
            QgsMessageLog.logMessage("No attribute loadCount for this resource", 'GeoPortal.rlp search',
                                         level=Qgis.Info)
        # add further information
        #select domain from comboBox
        search_domain = str(self.dlg.comboBoxSearchCatalogue.currentData())
        # search_domain = "https://www.geoportal.rlp.de"
        search_path = "/mapbender/php/mod_exportWmc.php" #?wmcId=14971&outputFormat=json"
        load_parameters = {
            "outputFormat": "json",
            "wmcId": str(resource_id),
        }
        # add parameter
        request_url = search_domain + search_path + "?" + urllib.parse.urlencode(load_parameters)

        #"https://www.geoportal.rlp.de/mapbender/php/mod_exportWmc?wmcId=666&outputFormat=json"
        self.dlg.labelAccessUrl.setText('<a href="' + request_url + '">GetCapabilities</a>')
        self.dlg.labelAccessUrl.setOpenExternalLinks(True)

        # respOrg
        self.dlg.labelOrga.setText(str(item.data(1, 0).respOrg))
        # date
        self.dlg.labelDate.setText(str(item.data(1, 0).date))
        # title
        # abstract
        self.dlg.textBrowserResourceAbstract.append(str(item.data(1, 0).title))
        self.dlg.textBrowserResourceAbstract.append(" - " + str(item.data(1, 0).abstract))

        # mdLink
        self.dlg.labelMetadata.setText('<a href="' + str(item.data(1, 0).mdLink) + '">Online Metadata</a>')
        self.dlg.labelMetadata.setOpenExternalLinks(True)

        self.dlg.pushButtonLoad.setEnabled(True)
        self.dlg.pushButtonLoad.clicked.disconnect()
        self.dlg.pushButtonLoad.clicked.connect(self.load_ows_context)


    def on_clicked_layer(self, item):
        """Show detailed information about wmc in other """
        self.reset_resource_view()
        self.dlg.labelResourceType.setText("Map layer")
        try:
            resource_id = item.data(1, 0).id
        except:
            QgsMessageLog.logMessage("No attribute id for this resource - no detailed info available", 'GeoPortal.rlp search',
                                         level=Qgis.Info)
            resource_id = 0


        #self.dlg.labelResourceId.setText("")
        self.dlg.pushButtonLoad.setEnabled(False)
        #self.dlg.textBrowserResourceAbstract.clear()
        self.dlg.treeWidgetResourceDetail.clear()
        # TODO alter this for clicked item in tree widget
        self.dlg.textBrowserResourceAbstract.append(item.text(0))

        try:
            abstract = str(item.data(1, 0).abstract)
            self.dlg.textBrowserResourceAbstract.append(" - " + abstract)
        except:
            QgsMessageLog.logMessage("No attribute abstract for this resource", 'GeoPortal.rlp search',
                                         level=Qgis.Info)
        # load preview image
        try:
            preview_url = item.data(1, 0).previewURL
            result_content = self.open_remote(preview_url)
            if result_content:
                # build
                pixmap = QPixmap()
                pixmap.loadFromData(result_content)
                # draw preview
                self.dlg.labelPreview.setPixmap(pixmap)
            else:
                QgsMessageLog.logMessage("An error occured while try to open url: " + preview_url, 'GeoPortal.rlp search',
                                         level=Qgis.Critical)
        except:
            self.dlg.labelPreview.setText("No preview")

        # load extent - remote image is to slow!
        try:
            # get extent from json
            bbox = str(item.data(1, 0).bbox)
            self.dlg.labelExtent.setText("Extent (EPSG:4326): " + bbox)
        except:
            QgsMessageLog.logMessage("No attribute bbox for this resource", 'GeoPortal.rlp search',
                                         level=Qgis.Critical)
        # load extent image
        """
        try:
            # get extent from json
            bbox = item.data(1, 0).bbox
            bbox_list = str(bbox).split(',')
            extent_url = "https://www.geoportal.rlp.de/cgi-bin/mapserv?map=/data/mapbender/tools/wms_extent/extents.map&VERSION=1.1.1&REQUEST=GetMap&SERVICE=WMS&LAYERS=demis,ows_layer_target,extent,metadata_polygon&STYLES=&SRS=EPSG:4326&BBOX=4,45,9,56&WIDTH=120&HEIGHT=120&FORMAT=image/png&BGCOLOR=0xffffff&TRANSPARENT=TRUE&EXCEPTIONS=application/vnd.ogc.se_inimage&minx=" + bbox_list[0] + "&miny=" + bbox_list[1] + "&maxx=" + bbox_list[2] + "&maxy=" + bbox_list[3]
            result_content = self.open_remote(extent_url)
            if result_content:
                # build
                pixmap = QPixmap()
                pixmap.loadFromData(result_content)
                # draw preview
                self.dlg.labelExtent.setPixmap(pixmap)
            else:
                QgsMessageLog.logMessage("An error occured while try to open url: " + extent_url, 'GeoPortal.rlp search',
                                         level=Qgis.Critical)
        except:
            self.dlg.labelExtent.setText("No Extent")
        """
        # add load count
        try:
            load_count = item.data(1, 0).loadCount
            self.dlg.labelLoadCount.setText(str(item.data(1, 0).loadCount))
        except:
            QgsMessageLog.logMessage("No attribute loadCount for this resource", 'GeoPortal.rlp search',
                                         level=Qgis.Info)
        # set access url and activate load button, if the url ia available
        self.dlg.labelResourceId.setText(str(resource_id))
        try:
            capabilities_url = str(item.data(1, 0).getCapabilitiesUrl)
            self.dlg.labelAccessUrl.setText('<a href="' + capabilities_url + '">GetCapabilities</a>')
            self.dlg.labelAccessUrl.setOpenExternalLinks(True)
            # add function to load button
            self.dlg.pushButtonLoad.setEnabled(True)
            self.dlg.pushButtonLoad.disconnect()
            self.dlg.pushButtonLoad.clicked.connect(lambda: self.add_ows(capabilities_url))
        except:
            QgsMessageLog.logMessage("No attribute getCapabilitiesUrl for this resource", 'GeoPortal.rlp search',
                                         level=Qgis.Info)
        try:
            metadata_url = str(item.data(1, 0).mdLink)
            self.dlg.labelMetadata.setText('<a href="' + metadata_url + '">Online Metadata</a>')
            self.dlg.labelMetadata.setOpenExternalLinks(True)
        except:
            QgsMessageLog.logMessage("No attribute getCapabilitiesUrl for this resource", 'GeoPortal.rlp search',
                                         level=Qgis.Info)
        # pull top level information - this is the information of the service itself
        top_level_item = item
        i = 0
        while top_level_item.parent():
            i = i + 1
            top_level_item = top_level_item.parent()
        top_level_item = top_level_item.child(0) # cause the top level ist not the service, but the header
        try:
            resp_org = str(top_level_item.data(1, 0).respOrg)
            self.dlg.labelOrga.setText(resp_org)
        except:
            QgsMessageLog.logMessage("No attribute respOrg for this resource", 'GeoPortal.rlp search',
                                         level=Qgis.Info)
        try:
            date = str(top_level_item.data(1, 0).date)
            # TODO - use iso format
            self.dlg.labelDate.setText(date)
        except:
            QgsMessageLog.logMessage("No attribute date for this resource", 'GeoPortal.rlp search',
                                         level=Qgis.Info)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GeoportalRlpMetadataSearchDialog()

            for resource in self.search_resources_list:
                self.dlg.comboBoxSearchResources.addItem(resource["title"], resource["value"])

            # search_catalogues
            for resource in self.search_catalogues:
                self.dlg.comboBoxSearchCatalogue.addItem(resource["title"], resource["value"])

            # important - events should only be added once - otherwise we will go into trouble!
            self.dlg.pushButton.clicked.connect(lambda: self.start_search(page=1, resource_type=self.dlg.comboBoxSearchResources.currentData()))
            self.dlg.pushButtonLoad.clicked.connect(self.load_ows_context)
            # add logo
            logo_url = "https://www.geoportal.rlp.de/static/useroperations/images/logo-geoportal.png"
            result_content = self.open_remote(logo_url)
            if result_content:
                # build
                pixmap = QPixmap()
                pixmap.loadFromData(result_content)
                # draw preview
                self.dlg.labelLogo.setPixmap(pixmap.scaled( self.dlg.labelLogo.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
            else:
                QgsMessageLog.logMessage("An error occured while try to open url: " + request_url, 'GeoPortal.rlp search',
                                         level=Qgis.Critical)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass


    def load_ows_context(self):
        # get ows context id from label_field
        context_id = int(self.dlg.labelResourceId.text())
        # search_domain = "https://www.geoportal.rlp.de"
        search_domain = str(self.dlg.comboBoxSearchCatalogue.currentData())
        search_path = "/mapbender/php/mod_exportWmc.php" #?wmcId=14971&outputFormat=json"
        load_parameters = {
            "outputFormat": "json",
            "wmcId": context_id,
        }
        # add parameter
        request_url = search_domain + search_path + "?" + urllib.parse.urlencode(load_parameters)
        QgsMessageLog.logMessage("Try to open url: " + request_url, 'GeoPortal.rlp search',
                                         level=Qgis.Info)
        result_content = self.open_remote(request_url)
        if result_content:
            result_object = json.loads(bytes(result_content).decode(), object_hook=lambda d: SimpleNamespace(**d))
        else:
            QgsMessageLog.logMessage("An error occured while try to open url: " + request_url, 'GeoPortal.rlp search',
                                         level=Qgis.Critical)
        for feature in result_object.features:
            for offering in feature.offerings:
                if offering.code == "http://www.opengis.net/spec/owc-atom/1.0/req/wms":
                    for operation in offering.operations:
                        if operation.code == "GetMap":
                            # add wms layer to qgis
                            # feature.titles
                            # self.dlg.textBrowser.append(feature.properties.title)
                            # layer name
                            # getmap
                            # ...scale hints
                            pass
        # build tree
        # tree = QTreeWidget()
        # last_folder = ""
        parent_node = QTreeWidgetItem()
        # parent_node.expandAll()
        # start_node = parent_node
        parent_node.setText(0, result_object.properties.title)
        self.dlg.treeWidgetResourceDetail.clear()
        # QgsMessageLog.logMessage("Widget cleared", 'GeoPortal.rlp search', level=Qgis.Info)
        self.build_tree_recursive(result_object.features, parent_node, "")
        self.dlg.treeWidgetResourceDetail.addTopLevelItem(parent_node)
        #self.dlg.treeWidgetResourceDetail.disconnect()
        self.dlg.treeWidgetResourceDetail.itemClicked.connect(self.on_clicked_context_layer)


    def build_layer_tree_recursive(self, srv, parent):
        QgsMessageLog.logMessage("srv: " + srv.title + " - type: " + str(type(srv)), 'GeoPortal.rlp search', level=Qgis.Info)
        try:
            iter(srv.layer)
            for layer in srv.layer:
                newTreeWidgetItem = QTreeWidgetItem()
                newTreeWidgetItem.setText(0, layer.title)
                newTreeWidgetItem.setData(1, 0, layer)
                parent.addChild(newTreeWidgetItem)
                self.build_layer_tree_recursive(layer, newTreeWidgetItem)
        except AttributeError:
            pass
                #features = list(filter(lambda num: num.properties.folder != feature.properties.folder, features))
                #self.build_layer_tree_recursive(layer, newTreeWidgetItem)


    def build_tree_recursive(self, features, parent, parent_path):
        # leaf consists of title, folder and feature object
        # "leaf 1", "/0", feature 1
        # "leaf 2", "/0/1", feature 2
        # "leaf 3", "/1", feature 3
        # and so on ...
        # we begin with parent object - ows context object - maybe it's title should be used
        # QgsMessageLog.logMessage("Actual parent_path to search for (top of function): " + parent_path, 'GeoPortal.rlp search', level=Qgis.Info)
        for feature in features:
            match = re.match("^" + parent_path + "/[0-9]+$", feature.properties.folder)
            if match:
                # QgsMessageLog.logMessage("Found feature with path: " + feature.properties.folder, 'GeoPortal.rlp search', level=Qgis.Info)
                # generate new QTreeWidgetItem
                newTreeWidgetItem = QTreeWidgetItem()
                # add information to item - first - 0 column will be used for title
                newTreeWidgetItem.setText(0, feature.properties.title)
                # https://doc.qt.io/qt-5/qtreewidgetitem.html#setData
                newTreeWidgetItem.setData(1, 0, feature)
                parent.addChild(newTreeWidgetItem)
                # delete feature with this folder from features array - cause it already exists
                features = list(filter(lambda num: num.properties.folder != feature.properties.folder, features))
                # QgsMessageLog.logMessage("Invoke recursive with path: " + feature.properties.folder, 'GeoPortal.rlp search', level=Qgis.Info)
                # invoke recursive with new folder string e.g. "/0"
                self.build_tree_recursive(features, newTreeWidgetItem, feature.properties.folder)


    def open_remote(self, url):
        """
        Howto to do it the QGIS way
        https://python.hotexamples.com/de/examples/qgis.core/QgsNetworkAccessManager/-/python-qgsnetworkaccessmanager-class-examples.html
        """
        request = QNetworkRequest()
        request.setUrl(QUrl(url))
        # manager = QgsNetworkAccessManager.instance()
        # blockingGet
        # result = manager.blockingGet(request, forceRefresh=True)
        result = self.na_manager.blockingGet(request)
        # https://qgis.org/api/classQgsNetworkReplyContent.html
        # byte_array
        return result.content()


    def reset_form(self, reset_input=False):
        if reset_input:
            self.dlg.textEditSearchText.clear()
        self.dlg.numberOfAllPagesLabel.setText('0')
        self.dlg.numberOfPageLabel.setText('0')
        self.dlg.numberOfAllResultsLabel.setText('0')
        self.dlg.treeWidgetResource.clear()
        self.dlg.textBrowserResourceAbstract.clear()
        self.dlg.treeWidgetResourceDetail.clear()
        self.dlg.pushButtonLoad.setEnabled(False)
        self.dlg.pushButtonPageBack.setEnabled(False)
        self.dlg.pushButtonPageForward.setEnabled(False)
        # very important thing:
        try:
            self.dlg.treeWidgetResource.itemClicked.disconnect()
        except:
            pass


    def reset_resource_view(self, reset_input=False):
        if reset_input:
            self.dlg.textEditSearchText.clear()
        self.dlg.labelResourceType.setText('')
        self.dlg.labelResourceId.setText('')
        self.dlg.labelPreview.setText('Preview...')
        self.dlg.labelExtent.setText('...')
        self.dlg.labelLoadCount.setText('')
        self.dlg.labelOrga.setText('')
        self.dlg.labelDate.setText('')
        self.dlg.labelLicence.setText('')
        self.dlg.labelRestrictions.setText('')
        self.dlg.labelAccessUrl.setText('')
        self.dlg.labelMetadata.setText('')
        self.dlg.textBrowserResourceAbstract.clear()


    def alter_pager(self, actual_page=1):
            self.dlg.pushButtonPageForward.disconnect()
            self.dlg.pushButtonPageBack.disconnect()
            self.dlg.pushButtonPageForward.clicked.connect(lambda: self.start_search(page=(actual_page + 1), resource_type=self.dlg.comboBoxSearchResources.currentData()))
            self.dlg.pushButtonPageBack.clicked.connect(lambda: self.start_search(page=(actual_page - 1), resource_type=self.dlg.comboBoxSearchResources.currentData()))


    def start_search(self, page=1, resource_type='wmc'):
        """
        Build initial search request
        https://documents.geoportal.rlp.de/mediawiki/index.php/SearchInterface
        """
        self.reset_form(False)
        self.reset_resource_view()
        # read search domain from comboBox
        search_domain = str(self.dlg.comboBoxSearchCatalogue.currentData())

        #search_domain = "https://www.geoportal.rlp.de"
        search_path = "/mapbender/php/mod_callMetadata.php"
        # get string from input field
        search_text_string = self.dlg.textEditSearchText.toPlainText()
        if search_text_string == "":
            search_text = "*"
        else:
            search_text = search_text_string
        search_parameters = {
            "searchResources": resource_type,
            "searchPages": page,
            "maxResults": 10,
            "resultTarget": "webclient",
            "searchEPSG": "EPSG:4326",
            "languageCode": "en",
            "searchText": search_text,
        }
        # add parameters
        request_url = search_domain + search_path + "?" + urllib.parse.urlencode(search_parameters)
        QgsMessageLog.logMessage("Try to open url: " + request_url, 'GeoPortal.rlp search',
                                         level=Qgis.Info)
        result_content = self.open_remote(request_url)
        if result_content:
            result_object = json.loads(bytes(result_content).decode(), object_hook=lambda d: SimpleNamespace(**d))
        else:
            QgsMessageLog.logMessage("An error occured while try to open url: " + request_url, 'GeoPortal.rlp search',
                                         level=Qgis.Critical)
        """ After the results came back from the metadata server"""
        self.dlg.treeWidgetResource.clear()
        self.dlg.pushButtonLoad.setEnabled(False)
        # read metadata from json
        if resource_type == 'wmc':
            number_of_results = result_object.wmc.wmc.md.nresults
            actual_page = int(result_object.wmc.wmc.md.p)
            results_per_page = int(result_object.wmc.wmc.md.rpp)
            search_time = result_object.wmc.wmc.md.genTime

        if resource_type == 'wms':
            number_of_results = result_object.wms.wms.md.nresults
            actual_page = int(result_object.wms.wms.md.p)
            results_per_page = int(result_object.wms.wms.md.rpp)
            search_time = result_object.wms.wms.md.genTime
        # Add info into form
        self.dlg.numberOfAllResultsLabel.setText(number_of_results)
        self.dlg.numberOfPageLabel.setText(str(actual_page))
        # Calculate number of all pages
        number_of_all_pages = math.ceil(int(number_of_results) / results_per_page)
        if actual_page < number_of_all_pages:
            self.dlg.pushButtonPageForward.setEnabled(True)
        if actual_page > 1:
            self.dlg.pushButtonPageBack.setEnabled(True)
        self.dlg.numberOfAllPagesLabel.setText(str(number_of_all_pages))
        QgsMessageLog.logMessage("Used seconds: " + str(search_time), 'GeoPortal.rlp search',
                                         level=Qgis.Info)
        # clear last results
        self.dlg.treeWidgetResource.clear()
        if resource_type == 'wmc':
            parent_node = QTreeWidgetItem()
            parent_node.setText(0, "Found OWS Context documents")
            for wmc in result_object.wmc.wmc.srv:
                # self.dlg.textBrowser.append(str(wmc.title))
                # self.dlg.listWidget.disconnect()
                # all_items = self.dlg.listWidget.findItems('*', Qt.MatchWildcard)
                # for item in all_items:
                # item.disconnect()
                # treeWidget version
                wmc_node = QTreeWidgetItem()
                wmc_node.setText(0, wmc.title)
                wmc_node.setData(1, 0, wmc)
                parent_node.addChild(wmc_node)
            self.dlg.treeWidgetResource.expandAll()
        if resource_type == 'wms':
            parent_node = QTreeWidgetItem()
            parent_node.setText(0, "Found map layers (WMS)")
            QgsMessageLog.logMessage("Found " + str(len(result_object.wms.wms.srv)) + " srv objects" , 'GeoPortal.rlp search', level=Qgis.Info)
            for wms in result_object.wms.wms.srv:
                # self.dlg.textBrowser.append(str(wmc.title))
                # create service layer item
                wms_node = QTreeWidgetItem()
                wms_node.setText(0, wms.title)
                # add relevant service data to layer object
                wms_node.setData(1, 0, wms)
                """
                Create layer items recursively
                """
                # QgsMessageLog.logMessage("Widget cleared", 'GeoPortal.rlp search', level=Qgis.Info)
                # add layers
                self.build_layer_tree_recursive(wms, wms_node)
                #add service node to result list
                parent_node.addChild(wms_node)
        self.dlg.treeWidgetResource.addTopLevelItem(parent_node)
        self.dlg.treeWidgetResource.expandAll()
        if resource_type == "wmc":
            self.dlg.treeWidgetResource.itemClicked.connect(self.on_clicked_wmc)
        if resource_type == "wms":
            self.dlg.treeWidgetResource.itemClicked.connect(self.on_clicked_layer)
        #self.dlg.treeWidgetResource.itemClicked.connect(lambda: self.on_clicked_resource(self, resource_type))
        self.alter_pager(actual_page)

